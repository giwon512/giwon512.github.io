---
layout: single
title: í”„ë¡œê·¸ë˜ë¨¸ìŠ¤ Lv3 í‘œ ë³‘í•©
categories: ['Algorithm']
tag: [coding, Java, kakao]
---



ì§ˆë¬¸í•˜ê¸° íƒ­ì„ ë³´ë‹ˆ `union-find` ì•Œê³ ë¦¬ì¦˜ì„ í™œìš©í•˜ì—¬ ë¬¸ì œë¥¼ í•´ê²°í–ˆë‹¤ëŠ” ë‚´ìš©ì´ ë§ì´ ë³´ì´ë˜ë°, ë”°ë¡œ ì•Œê³ ë¦¬ì¦˜ì„ ì•Œì§€ ì•Šì•„ë„ ì¶©ë¶„íˆ í•´ê²°í•  ìˆ˜ ìˆì„ ê²ƒ ê°™ì•„ ë¬´ì‹í•˜ê²Œ ì‹œí–‰ì°©ì˜¤ë¥¼ ì”ëœ© ê²ªìœ¼ë©° ë¬¸ì œë¥¼ í’€ì—ˆë‹¤. í’€ê³  ë‚˜ì„œ ì•Œê³ ë¦¬ì¦˜ì„ ì°¾ì•„ë³´ë‹ˆ ë‚´ê°€ í‘¼ ë°©ì‹í•˜ê³  ê²°êµ­ ê°™ì€ ë°©ì‹ì´ë¼ ë¿Œë“¯í–ˆê³ , ê°€ë§Œ ìƒê°í•´ë³´ë‹ˆ ë°±ì¤€ì—ì„œ ë§ì´ í’€ì—ˆë˜ ë¶„ë¦¬ ì§‘í•© ë¬¸ì œì„ì„ ì•Œ ìˆ˜ ìˆì—ˆë‹¤.

## ğŸ“˜ ë¬¸ì œ ì„¤ëª…

[https://school.programmers.co.kr/learn/courses/30/lessons/150366](https://school.programmers.co.kr/learn/courses/30/lessons/150366)

## ğŸ“˜ ìš”êµ¬ ì‚¬í•­

ì‹¤í–‰í•  ëª…ë ¹ì–´ë“¤ì´ ë‹´ê¸´ 1ì°¨ì› ë¬¸ìì—´ ë°°ì—´Â `commands`ê°€ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§‘ë‹ˆë‹¤.Â `commands`ì˜ ëª…ë ¹ì–´ë“¤ì„ ìˆœì„œëŒ€ë¡œ ì‹¤í–‰í•˜ì˜€ì„ ë•Œ,Â `"PRINT r c"`Â ëª…ë ¹ì–´ì— ëŒ€í•œ ì‹¤í–‰ê²°ê³¼ë¥¼ ìˆœì„œëŒ€ë¡œ 1ì°¨ì› ë¬¸ìì—´ ë°°ì—´ì— ë‹´ì•„ return í•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.

## ğŸ“– ë¬¸ì œ í•´ê²° ì „ëµ

- ê° ì…€ì— ëŒ€í•œ ì •ë³´ë¥¼ ì €ì¥í•˜ëŠ” í´ë˜ìŠ¤ë¥¼ ë§Œë“¤ê³ , ë¶€ëª¨ì™€ ìì‹ ë…¸ë“œë“¤ì˜ ì •ë³´ë¥¼ ë©¤ë²„ ë³€ìˆ˜ë¡œ ê´€ë¦¬í•´ì„œ mergeì™€ unmergeë¥¼ ìˆ˜í–‰í•˜ê³ ì í•˜ì˜€ë‹¤.
    
    ### Cell Class
    
    ```java
    class Cell{
    	String data = null;
    	int row;
    	int col;
    	Cell parent = null;
    	ArrayList<Cell> children = new ArrayList<>();
    	
    	Cell(int row, int col){
    		this.row = row;
    		this.col = col;
    	}
    	
    	String getData() {
    		if(data == null) {
    			return "EMPTY";
    		}
    		else {
    			return data;
    		}
    	}
    }
    ```
    
    ë¶€ëª¨ì™€ ìì‹ ê´€ê³„ì˜ ì…€ë“¤ì„ ë©¤ë²„ ë³€ìˆ˜ë¡œ ì €ì¥í•´ë†“ê³  ì •ë³´ë“¤ì„ ê´€ë¦¬í•˜ê³ ì í–ˆë‹¤.
    
    ### MERGE
    
    ì´ ë¬¸ì œì—ì„œ ê°€ì¥ ì‹ ê²½ì„ ì¨ì•¼ í•  ë¶€ë¶„ì€ mergeì˜€ê¸°ì— ì´ ë¶€ë¶„ë§Œ ë‹¤ë£¨ì–´ë³´ê² ë‹¤.
    
    ```java
    case "MERGE":
    	int r1 = Integer.parseInt(command[1]) - 1;
    	int c1 = Integer.parseInt(command[2]) - 1;
    	int r2 = Integer.parseInt(command[3]) - 1;
    	int c2 = Integer.parseInt(command[4]) - 1;
    	
    	Cell front = table[r1][c1];
    	Cell back = table[r2][c2];
    	while(front.parent != null) {
    		front = front.parent;
    	}
    	while(back.parent != null) {
    		back = back.parent;
    	}
    	if(front == back) 
    		break;
    	
    	mergeCell(r1, c1, r2, c2);
    	break;
    ```
    
    **í•µì‹¬ì€ rootê°€ ê°™ì€ì§€ ë¹„êµí•˜ëŠ” ê²ƒ**ì´ë‹¤. ë¬¸ì œì˜ ì¡°ê±´ì—ì„œ,  `ì„ íƒí•œ ë‘ ìœ„ì¹˜ì˜ ì…€ì´ ê°™ì€ ì…€ì¼ ê²½ìš° ë¬´ì‹œí•©ë‹ˆë‹¤.` ë¼ëŠ” ë¬¸êµ¬ë¥¼ ë³´ê³  í–‰ê³¼ ì—´ì„ ë¹„êµí•´ì„œ ê°™ì€ì§€ íŒë‹¨í•˜ì˜€ëŠ”ë°, ê·¸ê²Œ íŒ¨ì°©ì´ì—ˆë‹¤. ê³„ì†í•´ì„œ í‹€ë¦° ì´ìœ ëŠ” ë‘ ê°€ì§€ì˜€ë‹¤.
    
    - ë£¨íŠ¸ê°€ ê°™ì€ ë‘ ì…€ì„ í•©ì¹˜ë©´ ë¬´í•œ ë£¨í”„ê°€ ë°œìƒ
    - ë£¨íŠ¸ê°€ ë‹¤ë¥¸ ë‘ ì…€ì„ í•©ì¹˜ë”ë¼ë„ ë£¨íŠ¸ê°€ ë˜ëŠ” ì…€ì„ í•©ì³ì£¼ì–´ì•¼ ë¬¸ì œê°€ ë°œìƒí•˜ì§€ ì•ŠëŠ”ë‹¤.
    
    ```java
    void mergeCell(int r1, int c1, int r2, int c2) {
    		Queue<Cell> queue = new LinkedList<>();
    		//ì´ì–´ ë¶™ì¼ ì…€ì˜ ë£¨íŠ¸ë¥¼ ì°¾ì•„ì„œ ë¶™ì„
    		Cell curr = table[r2][c2];
    		while(curr.parent != null) {
    			curr = curr.parent;
    		}
    		curr.parent = table[r1][c1];
    		table[r1][c1].children.add(curr);
    		
    		//ë¬¸ì œì˜ ì¡°ê±´ì— ë”°ë¼ ê°’ì´ ìˆëŠ” ì§€ ì—†ëŠ” ì§€ì— ë”°ë¼ì„œ dataê°’ ê²°ì •
    		String input = null;
    		if(table[r1][c1].data != null && table[r2][c2].data != null) {
    			input = table[r1][c1].data;
    		}
    		else if(table[r1][c1].data != null) {
    			input = table[r1][c1].data;
    		}
    		else if(table[r2][c2].data != null) {
    			input = table[r2][c2].data;
    		}
    		//ì´ì–´ ë¶™ì¸ í›„ ë‹¤ì‹œ ë£¨íŠ¸ë¥¼ ì°¾ì•„ì¤Œ
        while(curr.parent != null) {
    			curr = curr.parent;
    		}
    		//bfsë¡œ ëª¨ë“  ì…€ì„ ìˆœíšŒí•˜ë©´ì„œ ê°’ì„ ë°”ê¿”ì¤Œ
    		queue.add(curr);
    		curr.data = input;
    		while(queue.size() != 0) {
    			Cell iter = queue.poll();
    			for(int i = 0; i < iter.children.size(); i++) {
    				iter.children.get(i).data = input;
    				queue.add(iter.children.get(i));
    			}
    		}
    	}
    ```
    
    í•©ì¹˜ê³  ë‚˜ëˆŒ ë•Œë§ˆë‹¤ ì—°ê²°ë˜ì–´ ìˆëŠ” ëª¨ë“  ì…€ë“¤ì˜ ê°’ì´ ë³€ê²½ë˜ê¸° ë•Œë¬¸ì— bfsë¡œ ì—°ê²°ë˜ëŠ” ì…€ë“¤ì„ ì¼ì¼ì´ ì°¾ì•„ì„œ ê´€ë¦¬í•´ì£¼ì—ˆë‹¤. 
    

## ğŸ“– ë‹¤ë¥¸ í’€ì´

ë¶„ë¦¬ ì§‘í•©ì„ í’€ë©´ì„œ í™œìš©í–ˆë˜ `union-find` ì•Œê³ ë¦¬ì¦˜ì„ í™œìš©í•˜ë©´ í›¨ì”¬ ì§ê´€ì ì¸ í’€ì´ê°€ ê°€ëŠ¥í–ˆë‹¤.

### find í•¨ìˆ˜

```java
static int find(int idx){
    if(idx == grp[idx]){
        return idx;
    }
    //ê·¸ë£¹ ëŒ€í‘œ ê°±ì‹ 
    return grp[idx] = find(grp[idx]);
}
```

ì• ì´ˆì— ê°’ì„ ì°¾ì„ ë•Œ ë£¨íŠ¸ì˜ ì •ë³´ë¥¼ ê°±ì‹ í•´ì¤˜ì„œ ì‹œê°„ì„ ì¤„ì¼ ìˆ˜ ìˆê³ , ë‚´ê°€ ì‹ ì¤‘í•˜ê²Œ ìƒê°í•˜ì§€ ëª»í–ˆë˜ ë£¨íŠ¸ë“¤ ê°„ì˜ ë¹„êµê°€ ìì—°ìŠ¤ëŸ½ê²Œ ê°€ëŠ¥í•´ì§„ë‹¤.

### union í•¨ìˆ˜

```java
static void union(int g1, int g2){
    g1 = find(g1);
    g2 = find(g2);
    
    //ì´ë¯¸ ê°™ì€ ê·¸ë£¹ì¼ ê²½ìš° ë°”ë¡œ ë¦¬í„´
    if(g1 == g2){
        return;
    }
    //g1ì„ ëŒ€í‘œë¡œ ë‘ ê·¸ë£¹ì„ ë³‘í•©
    values[g2] = null;
    grp[g2] = g1;
}
```

## ğŸ“– ì „ì²´ ì½”ë“œ

```java
import java.util.*;

class Solution {
    Cell[][] table = new Cell[50][50];
	public String[] solution(String[] commands) {
		ArrayList<String> printed = new ArrayList<>();
        initialize();
        for(String s : commands) {
        	String[] command = s.split(" ");
        	switch(command[0]) {
        	case "UPDATE":
        		if(command.length == 4) {
        			int r = Integer.parseInt(command[1]) - 1;
        			int c = Integer.parseInt(command[2]) - 1;
        			String temp = command[3];
        			
        			updateCell(r, c, temp);
        		}
        		else {
        			for(int i = 0; i < 50; i++) {
        				for(int j = 0; j < 50; j++) {
        					if(table[i][j].data != null && table[i][j].data.equals(command[1])) {
        						table[i][j].data = command[2];
        					}
        				}
        			}
        		}
        		break;
        	case "MERGE":
        		int r1 = Integer.parseInt(command[1]) - 1;
        		int c1 = Integer.parseInt(command[2]) - 1;
        		int r2 = Integer.parseInt(command[3]) - 1;
        		int c2 = Integer.parseInt(command[4]) - 1;
        		
        		Cell front = table[r1][c1];
        		Cell back = table[r2][c2];
        		while(front.parent != null) {
        			front = front.parent;
        		}
        		while(back.parent != null) {
        			back = back.parent;
        		}
        		if(front == back) 
        			break;
        		
        		mergeCell(r1, c1, r2, c2);
        		break;
        	case "UNMERGE":
        		int r = Integer.parseInt(command[1]) - 1;
        		int c = Integer.parseInt(command[2]) - 1;
        		
        		unmergeCell(r, c);
        		break;
        	case "PRINT":
        		r = Integer.parseInt(command[1]) - 1;
        		c = Integer.parseInt(command[2]) - 1;
        		
        		printed.add(table[r][c].getData());
        		break;
        	default:
        		break;
        	}
        }
//        for(int i = 0; i < 4; i++) {
//        	for(int j = 0; j < 4; j++) {
//        		System.out.print(table[i][j].data + "\t\t");
//        	}
//        	System.out.println();
//        }
		String[] answer = new String[printed.size()];
		for(int i = 0; i < printed.size(); i++) {
			answer[i] = printed.get(i);
		}
        return answer;
    }
	
	void mergeCell(int r1, int c1, int r2, int c2) {
		Queue<Cell> queue = new LinkedList<>();
		Cell curr = table[r2][c2];
		while(curr.parent != null) {
			curr = curr.parent;
		}
		curr.parent = table[r1][c1];
		table[r1][c1].children.add(curr);
		
		String input = null;
		if(table[r1][c1].data != null && table[r2][c2].data != null) {
			input = table[r1][c1].data;
		}
		else if(table[r1][c1].data != null) {
			input = table[r1][c1].data;
		}
		else if(table[r2][c2].data != null) {
			input = table[r2][c2].data;
		}
        while(curr.parent != null) {
			curr = curr.parent;
		}
		queue.add(curr);
		curr.data = input;
		while(queue.size() != 0) {
			Cell iter = queue.poll();
			for(int i = 0; i < iter.children.size(); i++) {
				iter.children.get(i).data = input;
				queue.add(iter.children.get(i));
			}
		}
	}
	
	void unmergeCell(int r, int c) {
		Queue<Cell> queue = new LinkedList<>();
		
		Cell curr = table[r][c];
		while(curr.parent != null) {
			curr = curr.parent;
		}
		
		queue.add(curr);
		if(curr.row != r || curr.col != c) {
			curr.data = null;
		}
		while(queue.size() != 0) {
			Cell iter = queue.poll();
			for(int i = 0; i < iter.children.size(); i++) {
//				System.out.println("row: " + iter.children.get(i).row + " col: " + iter.children.get(i).col);
//				System.out.println("data: " + iter.children.get(i).data);
				if(iter.children.get(i).row != r || iter.children.get(i).col != c) {
					iter.children.get(i).data = null;
				}
				iter.children.get(i).parent = null;
				queue.add(iter.children.get(i));
			}
			iter.children.clear();
		}
	}
	
	void updateCell(int r, int c, String temp) {
		Queue<Cell> queue = new LinkedList<>();
		//find root
		Cell curr = table[r][c];
		while(curr.parent != null) {
			curr = curr.parent;
		}
		queue.add(curr);
		curr.data = temp;
		while(queue.size() != 0) {
			Cell iter = queue.poll();
			for(int i = 0; i < iter.children.size(); i++) {
				iter.children.get(i).data = temp;
				queue.add(iter.children.get(i));
			}
		}
	}
	
	void initialize() {
		for(int i = 0; i < 50; i++) {
			for(int j = 0; j < 50; j++) {
				table[i][j] = new Cell(i, j);
			}
		}
	}

}

class Cell{
	String data = null;
	int row;
	int col;
	Cell parent = null;
	ArrayList<Cell> children = new ArrayList<>();
	
	Cell(int row, int col){
		this.row = row;
		this.col = col;
	}
	
	String getData() {
		if(data == null) {
			return "EMPTY";
		}
		else {
			return data;
		}
	}
}
```